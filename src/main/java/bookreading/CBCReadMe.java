package bookreading;

/**
 * Created by Herve on 2017/2/19.
 */
public class CBCReadMe {

    /**
     * 计算机开机以后就开始运行, 根据存储器中储存的代码来改变存储器的内容, 简单来说, 计算机的体系结
     * 仅此而已
     *
     * 将数据从存储器读入寄存器的操作称为[加载load], 将数据从寄存器写回储存器的操作称为[写回store]
     *
     * 这是如果根据应用程序来区分可用的地址, 程序编写就会非常麻烦
     * 在可以同时运行多道程序的现代计算机中, 在 CPU和 OS的协作下, 所有的进程看上去都可用使用
     * 从 0地址开始的独立的储存器地址
     *
     * 具体来说, 这样使进程看上去独占储存器的机制是下面这样的
     * 首先将物理内存分割成大小 4KB或 8KB 的单位, 这样的单位称为 页page
     * 接着, 当进程需要内存时, OS会将新的页分配给进程, 并将此虚拟地址和物理地址的对应关系记录到
     * OS的地址转换表中, 之后就是 CPU的工作了, 进程使用虚拟地址访问储存器时, CPU内部称为 MMU
     * 的设备会访问地址转换表进行转换
     *
     * C语言的指针就是保存 [虚拟地址] 的数据类型
     *
     * 其实xx位寄存器的定义比较模糊, 但至少满足两个条件:
     * 1. 具备n位宽的通用寄存器
     * 2. 具备n位宽的地址空间
     *
     * IA-32中各进程地址空间的一部分被作为栈使用, 用于保存函数的临时变量和参数
     * 机器栈位于各进程地址空间中靠近 3GB之处, 向 0地址方向延伸, 即机器栈是从靠后的地址向前延伸
     *
     * MSB(Most Significant Bit) 最高位
     * LSB(Least Significant Bit) 最低位
     *
     * 对齐(alignment)是指将数据放在内存上时, 必须放置在特定数值的倍数的地址上
     * 例如, 必须放置在4的倍数的地址上, 这样的限制就是4字节对齐限制
     * 最近设计的CPU中有着所有的数据必须放置在该数据大小的倍数的地址上这样的限制
     * 违反上述限制就会发生[总线错误 bus error], 导致程序异常终止
     * IA-32并非最近设计的, 因此即便不对齐也只是影响速度而已
     */
}
